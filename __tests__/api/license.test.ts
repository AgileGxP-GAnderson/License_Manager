import { faker } from '@faker-js/faker';
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { createMocks } from 'node-mocks-http';
import { NextRequest } from 'next/server';
import { getDbInstance } from '../../lib/db';
const db = getDbInstance();
import { Sequelize } from 'sequelize';
// Import the route handlers
import * as licensesRoute from '../../app/api/licenses/route';
import * as licenseIdRoute from '../../app/api/licenses/[id]/route';
import { LicenseOutput, LicenseInput } from '@/lib/models/license';
import { LicenseTypeLookupOutput } from '@/lib/models/licenseTypeLookup';

// Helper function
function createMockNextRequest(options: any): NextRequest {
    const { req } = createMocks(options);
    req.nextUrl = {
        // @ts-ignore
        searchParams: new URLSearchParams(options.query || {}),
    };
    // @ts-ignore
    req.json = async () => options.body || {};
    return req as unknown as NextRequest;
}

// Helper to create a License Type via DB for test setup
// Note: Ideally, we'd have an API for this too and use that helper
async function createLicenseTypeDirectly(data: { name: string }): Promise<LicenseTypeLookupOutput> {
    const newType = await db.LicenseTypeLookup.create(data);
    return newType.get({ plain: true }) as LicenseTypeLookupOutput;
}

// Helper to create a License via API for test setup
async function createLicenseViaApi(data: Partial<LicenseInput>): Promise<LicenseOutput> {
    const req = createMockNextRequest({ method: 'POST', body: data });
    const response = await licensesRoute.POST(req);
    if (response.status !== 201) {
        const errorText = await response.text();
        throw new Error(`Failed to create license for test setup: ${response.status} - ${errorText}`);
    }
    // API returns license with type data
    return await response.json();
}


describe('License API Routes', () => {
  let sequelize: Sequelize;
  let testLicenseType: LicenseTypeLookupOutput;

  beforeAll(async () => {
    sequelize = db.sequelize;
    // Global setup handles DB sync

    // Create a license type needed for tests
    testLicenseType = await createLicenseTypeDirectly({
        name: `TestType-${Date.now()}`,
    });
  });

   afterAll(async () => {
    // Clean up created license type if needed
    // await db.LicenseTypeLookup.destroy({ where: { id: testLicenseType.id }});
    await sequelize.close();
  });

  // --- Test POST /api/licenses ---
  describe('POST /api/licenses', () => {
    it('should create a new license successfully', async () => {
      const newLicenseData = {
        externalName: `License_${faker.string.alphanumeric(8)}`,
        typeId: testLicenseType.id,
        // uniqueId is generated by default
      };

      const req = createMockNextRequest({ method: 'POST', body: newLicenseData });
      const response = await licensesRoute.POST(req);
      const json = await response.json();

      expect(response.status).toBe(201);
      expect(json).toHaveProperty('id');
      expect(json).toHaveProperty('uniqueId');
      expect(json.externalName).toBe(newLicenseData.externalName);
      expect(json.typeId).toBe(newLicenseData.typeId);
      expect(json.type).toBeDefined(); // Check included association
      expect(json.type.id).toBe(testLicenseType.id);

      // Verify in DB
      const licenseInDb = await db.License.findByPk(json.id);
      expect(licenseInDb).not.toBeNull();
      expect(licenseInDb?.externalName).toBe(newLicenseData.externalName);
    });

     it('should return 400 if required fields are missing', async () => {
        const incompleteData = { typeId: testLicenseType.id }; // Missing externalName
        const req = createMockNextRequest({ method: 'POST', body: incompleteData });
        const response = await licensesRoute.POST(req);
        expect(response.status).toBe(400);
    });

     it('should return 400 if typeId does not exist', async () => {
        const licenseData = {
            externalName: `License_${faker.string.alphanumeric(8)}`,
            typeId: 999999, // Non-existent type
        };
        const req = createMockNextRequest({ method: 'POST', body: licenseData });
        const response = await licensesRoute.POST(req);
        expect(response.status).toBe(400);
    });
  });

  // --- Test GET /api/licenses ---
  describe('GET /api/licenses', () => {
     it('should return a list containing created licenses', async () => {
        const lic1 = await createLicenseViaApi({ externalName: `ListLic1-${Date.now()}`, typeId: testLicenseType.id });
        const lic2 = await createLicenseViaApi({ externalName: `ListLic2-${Date.now()}`, typeId: testLicenseType.id });

        const req = createMockNextRequest({ method: 'GET' });
        const response = await licensesRoute.GET(req);
        const json = await response.json();

        expect(response.status).toBe(200);
        expect(Array.isArray(json)).toBe(true);
        const responseLicenses = json as LicenseOutput[];
        expect(responseLicenses.some((l) => l.id === lic1.id)).toBe(true);
        expect(responseLicenses.some((l) => l.id === lic2.id)).toBe(true);
     });
  });

  // --- Test GET /api/licenses/:id ---
  describe('GET /api/licenses/:id', () => {
    it('should return a specific license if found', async () => {
        const license = await createLicenseViaApi({ externalName: `FetchLic-${Date.now()}`, typeId: testLicenseType.id });
        const req = createMockNextRequest({ method: 'GET' });
        const context = { params: { id: license.id.toString() } };

        const response = await licenseIdRoute.GET(req, context);
        const json = await response.json();

        expect(response.status).toBe(200);
        expect(json.id).toBe(license.id);
        expect(json.externalName).toBe(license.externalName);
        expect(json.typeId).toBe(testLicenseType.id);
        expect(json.type).toBeDefined();
    });

     it('should return 404 if license not found', async () => {
        const req = createMockNextRequest({ method: 'GET' });
        const context = { params: { id: '999999' } };
        const response = await licenseIdRoute.GET(req, context);
        expect(response.status).toBe(404);
    });
  });

   // --- Test PUT /api/licenses/:id ---
   describe('PUT /api/licenses/:id', () => {
        it('should update an existing license', async () => {
            const license = await createLicenseViaApi({ externalName: `UpdateLicOld-${Date.now()}`, typeId: testLicenseType.id });
            const newExternalName = `UpdateLicNew-${Date.now()}`;
            const updateData = { externalName: newExternalName };

            const req = createMockNextRequest({ method: 'PUT', body: updateData });
            const context = { params: { id: license.id.toString() } };
            const response = await licenseIdRoute.PUT(req, context);
            const json = await response.json();

            expect(response.status).toBe(200);
            expect(json.id).toBe(license.id);
            expect(json.externalName).toBe(newExternalName);
            expect(json.typeId).toBe(testLicenseType.id); // Should not change

            // Verify update in DB
            const updatedLicenseDb = await db.License.findByPk(license.id);
            expect(updatedLicenseDb?.externalName).toBe(newExternalName);
        });
   });

    // --- Test DELETE /api/licenses/:id ---
    describe('DELETE /api/licenses/:id', () => {
        it('should delete an existing license', async () => {
            const license = await createLicenseViaApi({ externalName: `DeleteLic-${Date.now()}`, typeId: testLicenseType.id });
            const licenseId = license.id;

            const req = createMockNextRequest({ method: 'DELETE' });
            const context = { params: { id: licenseId.toString() } };
            const response = await licenseIdRoute.DELETE(req, context);

            expect(response.status).toBe(204);

             // Verify in DB
            const deletedLicense = await db.License.findByPk(licenseId);
            expect(deletedLicense).toBeNull();
        });
   });

});
